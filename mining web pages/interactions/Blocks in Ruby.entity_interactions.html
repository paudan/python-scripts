<html>
    <head>
        <title>Blocks in Ruby Interactions</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    </head>
    <body>[caption id="<strong>attachment_80346</strong>" <strong>align=</strong>"<strong>alignright</strong>" <strong>width=</strong>"212"] Buy Ruby Pocket Reference . [/caption] 
 When we talk about <strong><strong><strong>blocks</strong></strong></strong> in <strong>Ruby</strong>, we're not usually talking about <strong>code</strong> <strong><strong><strong>blocks</strong></strong></strong> — or <strong><strong><strong>blocks</strong></strong></strong> of <strong>statements</strong> — as we might with other languages. We're talking about a special <strong>syntax</strong> in <strong>Ruby</strong>, and one of its idioms. I'll be discussing <strong>blocks</strong> in this <strong>article</strong>, plus a little about <strong>procs</strong> and lambdas. <strong>Ruby</strong>'s <strong>blocks</strong> are always associated with <strong>methods</strong>, which are sets of recallable procedures. Blocks can't get along very well by themselves. They are dependent on methods, which normally feed data to them. Without that <strong>data</strong>, a <strong>block</strong> can't do anything useful. It needs a parent to look after it. Blocks are anonymous and are sometimes referred to as nameless functions . <strong>Blocks</strong> are like <strong><strong>method</strong>s</strong> within another <strong>method</strong> that <strong>grab</strong> <strong>data</strong> from an enclosing <strong>method</strong>. If all this is unfamiliar to you, it may not make sense. <strong>Keep</strong> <strong>reading</strong> and I'll do my best to clear things up for you. <strong>Block</strong> <strong>syntax</strong> 
 Here is an <strong>example</strong> that <strong>uses</strong> a <strong>block</strong> with the each <strong>method</strong> from <strong>Ruby</strong>'s <strong>builtin</strong> <strong>Array</strong> class. The each method is an iterator. An <strong>iterator</strong> munches <strong>data</strong>, usually in <strong>sequence</strong>, and with a little <strong>help</strong>, can actually do <strong>something</strong> useful with that <strong>data</strong>. A block doesn't have to be an iterator, though that is how they are often used. <strong>First</strong>, we'll create an <strong><strong>array</strong></strong> containing the <strong>names</strong> of the <strong>Western</strong> states in the <strong>U.S.</strong>, and then iterate over that <strong><strong>array</strong></strong> with <strong>Array</strong> 's each <strong>method</strong>: 
 [crayon-56082082d7b3d262715708/<strong>]</strong> 
 The <strong>block parameter e</strong> is surrounded by vertical bars. The parameter could have any name you want. (I tend to make mine short.) This particular <strong>block</strong> <strong><strong>uses</strong></strong> the <strong>parameter</strong> locally to keep <strong>track</strong> of each <strong><strong>element</strong></strong> in the <strong><strong>array</strong></strong> west_states , and later <strong><strong>uses</strong></strong> it to do <strong>something</strong> with each <strong><strong>element</strong></strong> of the <strong><strong>array</strong></strong>, in this <strong>case</strong>, tidily printing <strong>strings</strong> to standard output. You can write a <strong>block</strong> with <strong>do</strong> and end , as <strong>shown</strong>, or with a pair of braces, as is most commonly <strong>do</strong>ne. The <strong>braces</strong> actually have higher <strong>precedence</strong> than do / end , and the <strong>syntax</strong> is more concise, as you can see: 
 [crayon-56082082d7b4d637945346/<strong>]</strong> 
 <strong>Multiple</strong> <strong>parameters</strong> 
 A <strong>block</strong> may use more than one parameter. <strong>Multiple</strong> <strong>parameters</strong> are separated by commas. Here we'll iterate over a <strong>hash</strong> with <strong>Hash</strong> 's own each <strong>method</strong>, where multiple <strong>parameters</strong> make <strong>sense</strong>: 
 [crayon-56082082d7b55564805757/<strong>]</strong> 
 By the <strong>way</strong>, <strong>hash</strong>es are handy <strong>containers</strong> for key-value pairs, as you might have guessed. Also, each has a <strong>synonym</strong> in <strong>Hash</strong> : each_pair . <strong>Life</strong> without <strong>blocks</strong> 
 What <strong>happens</strong> if you call the <strong>Array</strong> 's or <strong>Hash</strong> 's each <strong>method</strong> without a block? <strong>Well</strong>, <strong>iterators</strong> expect blocks. Without one, the each <strong>method</strong> simply returns an <strong>enumerator</strong>, nothing more. <strong>Iterator</strong> <strong>methods</strong> like each don't make much <strong>sense</strong> without blocks. For <strong>example</strong>, the <strong>upto</strong> or downto <strong>methods</strong> from <strong>Integer</strong> are fairly useless without blocks. <strong>Compare</strong> these <strong>calls</strong>, for <strong>example</strong>: 
 <strong>[</strong>crayon-56082082d7b5d055566786/] 
 With these: 
 <strong>[</strong>crayon-56082082d7b64343657285/] 
 Nothing doing with the last two, except returned enumerators. <strong>Sort</strong> of <strong>like</strong> watching grass grow. <strong>Scope</strong> 
 In <strong>Ruby</strong> 1.9 or later, if you use as a <strong><strong><strong>parameter</strong></strong></strong> as a variable <strong>name</strong> that already exists in the <strong>containing scope</strong>, the <strong>block</strong> <strong>assigns</strong> that <strong><strong><strong>parameter</strong></strong></strong> each successive <strong><strong>value</strong></strong> from the <strong>object</strong>, but the variable's <strong><strong>value</strong></strong> is unchanged, as you see here (the <strong>to_a</strong> <strong>method</strong> <strong>converts</strong> the <strong>range</strong> to an <strong>array</strong>): 
 [crayon-56082082d7b6c106768130/<strong>]</strong> 
 So don't worry about variable and <strong><strong><strong>parameter</strong></strong></strong> <strong>name</strong>s colliding in such <strong>instances</strong>, unless you are using a pre-1.9 interpreter. The <strong>yield statement</strong> 
 As you know by now, a <strong>block</strong> must follow a method call. But <strong>something</strong> you might not know is that any <strong>method call</strong> may be followed by a <strong><strong>block</strong></strong>, and you can invoke <strong>code</strong> in such a <strong><strong>block</strong></strong> with a yield statement. We don't always see <strong>yield</strong> at <strong>work</strong> — it is <strong>part</strong> of the underlying, implicit <strong>control structure</strong> of <strong>iterator</strong> methods. But here we'll use it explicitly. A <strong>yield statement</strong> executes a <strong>block</strong> associated with a method. I'll use some really simple <strong>code</strong> from my recent <strong>book</strong> <strong>Ruby Pocket Reference</strong>, 2nd Edition to illustrate. The following <strong>method</strong>, <strong>gim</strong>me , contains only a single <strong>yield statement</strong> and isn't ver exciting: 
 [crayon-56082082d7b74693612736/] 
 What so far does <strong>gim</strong>me do? Give <strong>gim</strong>me a <strong>call</strong> and find out (I'm doing this in <strong>irb</strong> , <strong>Ruby</strong>'s <strong>homegrown interactive programming environment</strong>): 
 [crayon-56082082d7b7b026036493/<strong>]</strong> 
 <strong>Uh</strong> oh. This <strong>error</strong> showed up because <strong>yield</strong> 's <strong>job</strong> is to execute the <strong>block</strong> that is associated with the <strong>method</strong>, and that's missing in the code. <strong>Avoid</strong> this <strong>error</strong> by using the block_given? method from Kernel . <strong>Redefine</strong> <strong>gim</strong>me with an if <strong>statement</strong>: 
 [crayon-56082082d7b83857171859/<strong>]</strong> 
 <strong>Try</strong> <strong>gim</strong>me again with a very simple <strong>block</strong> (not an iterator!) and without: 
 [crayon-56082082d7b8a869687801/<<strong>s</strong>trong><strong>]</strong></<strong>s</strong>trong> 
 Now <<strong>s</strong>trong>redefine gim</<strong>s</strong>trong>me to contain two <<strong>s</strong>trong><strong>yield</strong></<strong>s</strong>trong> <strong>s</strong>, and then call it with a <strong>block</strong>: 
 [crayon-56082082d7b91603795181/<<strong>s</strong>trong><strong>]</strong></<strong>s</strong>trong> 
 Another <strong>thing</strong> you ought know i<strong>s</strong> that after <<strong>s</strong>trong><strong>yield</strong></<strong>s</strong>trong> execute<strong>s</strong>, <strong>control</strong> goe<strong>s</strong> back to the <strong>s</strong>tatement immediately following it. There's certainly more to say about yield , but I'll leave it at that. <strong>Do</strong> <strong>blocks</strong> have <strong>return</strong> values? Just a <strong>note</strong> here, in closing, about <strong>return</strong> <strong>values</strong> and blocks. <strong>Blocks</strong> don't really have <strong>return</strong> <strong>values</strong>, not in the same <strong>way</strong> their <strong>parent</strong> methods can. If you use a <strong>return statement</strong> in a <strong>block</strong>, the <strong>containing method</strong> will return, not the <strong>block</strong>. A <strong>block</strong> <strong>yields</strong> the <strong>value</strong> of its last expression. You don't need to use return in a block, nor should you. <strong>blocks</strong>, <strong><strong>proc</strong>s</strong>, and <strong>lambdas</strong> 
 A <strong>proc</strong> is a <strong>way</strong> to store a <strong>proc</strong>edure in Ruby. Procs are often short, one-liners, though not always. One <strong>reason</strong> I'm bringing them up here is because a <strong><strong>proc</strong></strong> is not a <strong><strong>proc</strong></strong> without a <strong>block</strong> in Ruby. First, a little background. A proc is a first-class object that comes complete with context. As a first-class <strong>object</strong>, a <strong>proc</strong> can be created at <strong>runtime</strong>, stored in <strong>data structures</strong>, passed as a parameter, and so on. To create a <strong>proc</strong>, you can call <strong>Proc</strong>::new , <strong><strong>Kernel</strong></strong>#<strong>lambda</strong> , or <strong><strong>Kernel</strong></strong>#<strong>proc</strong> . The <strong>term lambda</strong> comes from <strong>Alonzo Church</strong>'s <strong>lambda calculus</strong> , which famously influenced the <strong>development</strong> of the <strong>Lisp</strong> <strong>programing language</strong> and more recent functional <strong>programming</strong> languages. <strong>Lambda</strong> <strong>logic</strong> can be found in a <strong>number</strong> of <strong>programming</strong> <strong>languages</strong>, including <strong>Lisp</strong>, <strong>Python</strong>, <strong>Swift</strong>, <strong>C</strong>#, and <strong>Ruby</strong>, among others. Generally, lambdas are anonymous functions that can be written inline and easily discarded. What's the <strong>difference</strong> between <strong>procs</strong> and lambdas? <strong>Lambdas</strong> behave more like <strong>methods</strong> and <strong>procs</strong> behave more like <strong>blocks</strong>, but both are <strong>instances</strong> of the <strong>Proc</strong> class. For brevity, I'll only show a lambda here. When creating a <strong>lambda</strong> with the <strong>methods</strong> mentioned, a block is required. <strong>Kernel</strong> 's <strong>lambda method</strong>, for <strong>example</strong>, expects a block. A <strong>call</strong> to lambda is equivalent to <strong>call</strong>ing Proc.new and both <strong>call</strong>s return a proc object. Here is a <strong><strong>call</strong></strong> to <strong>lambda</strong> which of <strong>necessity</strong> includes a <strong>block</strong>, followed by a <strong><strong>call</strong></strong> to the new <strong>proc</strong>: 
 <strong>[</strong>crayon-56082082d7b9a662250941/<strong>]</strong> 
 By the <strong>way</strong>, since 1.9, you can use the following simplified, <strong>lambda</strong> literal <strong>syntax</strong>, with the same <strong>result</strong>: 
 <strong>[</strong>crayon-56082082d7ba1900377019/<strong>]</strong> 
 There's much to learn about <strong>lambda</strong>s. I just wanted to show, briefly, how blocks are used with procs. A <strong>fuller treatment</strong> of <strong>procs merits</strong> another article. Summary 
 Let me wrap up with a brief <strong>summary</strong> of blocks. <strong>Blocks</strong> are essentially nameless <strong>functions</strong> that provide a <strong>concise way</strong> to iterate over objects. An <strong>iterator method</strong> such as each without a <strong>block</strong> will return only an enumerator. Blocks have one or more parameters. In <strong>addition</strong>, a <strong>block</strong> does not have a <strong>return value</strong> like a method. It yields the value of its last expression. Finally, stored <strong>procedures</strong> in <strong>Ruby —</strong> <strong>procs</strong> — <strong>use</strong> blocks as well. Thanks for reading. Happy coding. Note: If you'd like to get more <strong>detail</strong>, <strong>Mike</strong> suggests <strong>reading <strong>section</strong></strong> 5.4 on <strong><strong>blocks</strong></strong> and <strong>section</strong> 6.5 on <strong>procs</strong> and <strong>lambdas</strong> in The <strong>Ruby Programming Language</strong> by <strong>David Flanagan</strong> and <strong>Yukihiro Matsumoto</strong>, plus <strong>chapter</strong> 8 on <strong><strong>blocks</strong></strong> in <strong>Lucas Carlson</strong>'s Ruby Cookbook . Both are from O'Reilly. Public <strong>domain</strong> <strong>studs</strong> <strong>image</strong> via Pixabay .</body>
</html>