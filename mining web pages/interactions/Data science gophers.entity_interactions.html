<html>
    <head>
        <title>Data science gophers Interactions</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    </head>
    <body><strong>Python</strong> and <strong>R</strong> are widely accepted as logical <strong>languages</strong> for <strong>data</strong> science—but what about Go? If you follow the <strong>data</strong> <strong>science community</strong>, you have very likely seen <strong>something</strong> like <strong>“language</strong> wars” unfold between <strong>Python</strong> and <strong>R</strong> users. They seem to be the only choices. But there might be a <strong>somewhat</strong> surprising third <strong>option</strong>: <strong>Go</strong> , the open <strong>source programming language</strong> created at <strong>Go</strong>ogle. In this <strong>post</strong>, we are going to explore how the unique <strong>features</strong> of <strong><strong>Go</strong></strong>, along with the <strong>mindset</strong> of <strong><strong>Go</strong></strong> <strong>programmers</strong>, could help <strong>data scientists</strong> overcome common struggles. We are also going to peek into the <strong>world</strong> of Go-based <strong><strong><strong>data</strong></strong></strong> <strong><strong><strong>science</strong></strong></strong> to see what <strong>tools</strong> are available and how an ever-growing <strong>group</strong> of <strong><strong><strong>data</strong></strong></strong> <strong><strong><strong>science</strong></strong></strong> <strong>gophers</strong> are already solving real-<strong>world</strong> <strong><strong><strong>data</strong></strong></strong> <strong><strong><strong>science</strong></strong></strong> <strong>problems</strong> with Go. <strong>Go</strong>, a <strong>cure</strong> for common <strong>data</strong> <strong>science</strong> <strong>pains</strong> 

 <strong>Data</strong> <strong>scientists</strong> are already working in <strong>Python</strong> and <strong>R. These</strong> <strong>languages</strong> are undoubtedly producing <strong>value</strong>, and <strong>it’s</strong> not necessary to rehearse their <strong>virtues</strong> here, but, looking at the <strong>community</strong> of <strong>data</strong> <strong>scientists</strong> as a whole, certain struggles seem to surface quite frequently. The following <strong>pains</strong> commonly emerge as <strong>obstacles</strong> for <strong><strong><strong>data</strong></strong></strong> <strong>science</strong> <strong>teams</strong> working to provide <strong>value</strong> to a <strong>business</strong>: 


 
 
 <strong>Difficulties</strong> building <strong>“production-ready”</strong> <strong>applications</strong> or <strong>services</strong>: Unfortunately, the very <strong>process</strong> of interactively exploring <strong><strong><strong>data</strong></strong></strong> and developing <strong>code</strong> in <strong>notebooks</strong> along with the dynamically typed, single-threaded <strong>languages</strong> commonly used in <strong><strong><strong>data</strong></strong></strong> <strong>science</strong> cause <strong><strong><strong>data</strong></strong></strong> scientists to produce <strong>code</strong> that is almost impossible to productionize. There could be a huge <strong>amount</strong> of <strong>effort</strong> in <strong>transitioning</strong> a <strong>model</strong> off of a <strong>data scientist’s laptop</strong> into an <strong>application</strong> that could actually be deployed, handle <strong>errors</strong>, be tested, and log properly. This <strong>barrier</strong> of <strong>effort</strong> often causes <strong>data</strong> scientists’ <strong>models</strong> to stay on their <strong>laptops</strong> or, possibly worse, be deployed to <strong>production</strong> without <strong>proper</strong> monitoring, <strong>testing</strong>, etc. <strong>Jeff Magnussen</strong> at <strong>Stitchfix</strong> and <strong>Robert Chang</strong> at <strong>Twitter</strong> have each discussed these <strong>sorts</strong> of cases. <strong>Applications</strong> or <strong>services</strong> that don’t behave as expected: Dynamic <strong>typing</strong> and convenient <strong>parsing functionality</strong> can be wonderful, but these <strong>features</strong> of <strong>languages</strong> like <strong>Python</strong> or <strong>R</strong> can turn their <strong>back</strong> on you in a hurry. Without a great <strong>deal</strong> of <strong>forethought</strong> into <strong>testing</strong> and <strong>edge</strong> <strong>cases</strong>, you can end up in a <strong>situation</strong> where your <strong>data</strong> <strong>science application</strong> is behaving in a <strong>way</strong> you did not expect and cannot explain (<strong>e.g.</strong>, because the <strong>behavior</strong> is caused by errors that were unexpected and unhandled). This is dangerous for <strong>data</strong> <strong>science</strong> <strong>applications</strong> whose main <strong>purpose</strong> is to provide actionable <strong>insights</strong> within an organization. As soon as a <strong>data science application</strong> breaks down without <strong>explanation</strong>, <strong>people</strong> won’t <strong>trust</strong> it and, thus, will cease making data-driven <strong>decisions</strong> based on <strong>insights</strong> from the application. The <strong>Cookiecutter Data Science</strong> <strong>project</strong> is one notable <strong>effort</strong> at a “logical, reasonably standardized, but flexible <strong>project</strong> structure for doing and sharing <strong>data</strong> <strong>science</strong> work” in Python—but the static <strong>typing</strong> and <strong>nudges</strong> toward <strong>clarity</strong> of <strong>Go</strong> make these workflows more likely. An <strong>inability</strong> to integrate <strong><strong>data</strong></strong> <strong><strong>science development</strong></strong> into an <strong>engineering organization</strong>: Often, <strong><strong>data</strong></strong> engineers, <strong>devops engineers</strong>, and <strong>others</strong> view <strong><strong>data</strong></strong> <strong><strong>science development</strong></strong> as a mysterious <strong>process</strong> that produces <strong>inefficient</strong>, unscalable, and hard-to-support applications. Thus, <strong>data</strong> <strong>science</strong> can produce what <strong>Josh Wills</strong> at <strong>Slack</strong> <strong>calls</strong> an <strong>“ infinite-loop-of-sadness</strong> ” within an engineering organization. Now, if we look at <strong><strong>Go</strong></strong> as a potential <strong>language</strong> for <strong>data</strong> <strong>science</strong>, we can see that, for many <strong>use</strong> <strong>cases</strong>, it alleviates these <strong>struggles</strong>: 

 

 <strong><strong>Go</strong></strong> has a proven <strong>track record</strong> in <strong>production</strong>, with widespread <strong>adoption</strong> by <strong>devops engineers</strong>, as evidenced by game-changing <strong>tools</strong> like <strong>Docker</strong> , <strong>Kubernetes</strong> , and <strong>Consul</strong> being developed in <strong><strong>Go</strong></strong>. <strong>Go</strong> is just plain simple to deploy (via static <strong>binaries</strong> ), and it allows <strong>developers</strong> to produce readable, efficient <strong>applications</strong> that <strong>fit</strong> within a modern <strong>microservices</strong> architecture. In <strong>contrast</strong>, heavy-weight <strong>Python</strong> <strong>data</strong> <strong>science</strong> <strong>applications</strong> may need readability-killing <strong>packages</strong> like <strong>Twisted</strong> to fit into modern event-driven <strong>systems</strong> and likely rely on an <strong>ecosystem</strong> of tooling that <strong>takes</strong> significant effort to deploy. <strong>Go</strong> itself also provides amazing <strong>tooling</strong> for <strong>testing</strong>, formatting, <strong>vet</strong>ting, and linting (<strong>gofmt</strong>, go <strong>vet</strong>, <strong>etc</strong>.) that can easily be integrated in your <strong>workflow</strong> (<strong>see</strong> here for a <strong>starter guide</strong> with Vim). Combined, these <strong>features</strong> can help <strong>data scientists</strong> and <strong>engineers</strong> spend most of their <strong>time building</strong> interesting <strong>applications</strong> and <strong>services</strong>, without a huge barrier to deployment. Next, regarding expected behavior <strong>(</strong>especially with unexpected <strong>input</strong>) and <strong><strong>error</strong>s</strong>, <strong>Go</strong> certainly takes a different <strong>approach</strong>, compared to <strong>Python</strong> and R. <strong>Go</strong> <strong>code</strong> uses <strong>error</strong> <strong>values</strong> to indicate an abnormal <strong>state</strong>, and the <strong>language</strong>'s <strong>design</strong> and <strong>conventions</strong> encourage you to explicitly check for <strong><strong>error</strong>s</strong> where they occur. Some might take this as a negative <strong>(</strong>as it can introduce some <strong>verbosity</strong> and a different way of thinking). But for those using <strong><strong>Go</strong></strong> for <strong>data</strong> <strong>science work</strong>, <strong>handling</strong> <strong>errors</strong> in an idiomatic <strong><strong>Go</strong></strong> <strong>manner</strong> <strong>produces</strong> rock-solid <strong>applications</strong> with predictable behavior. Because <strong><strong>Go</strong></strong> is statically typed and because the <strong><strong>Go</strong></strong> <strong>community</strong> <strong>encourages</strong> and <strong>teaches</strong> handling <strong>errors</strong> gracefully , <strong>data scientists</strong> exploiting these <strong>features</strong> can have <strong>confidence</strong> in the <strong>applications</strong> and services they deploy. They can be sure that <strong>integrity</strong> is maintained over <strong>time</strong>, and they can be sure that, when <strong>something</strong> does behave in an unexpected <strong>way</strong>, there will be <strong>errors</strong>, <strong>logs</strong>, or other <strong>information</strong> helping them understand the issue. In the <strong>world</strong> of <strong>Python</strong> or <strong>R</strong>, <strong>errors</strong> may hide themselves behind convenience. For <strong>example</strong>, <strong>Python</strong> pandas will return a <strong>maximum value</strong> or a merged <strong>dataframe</strong> to you, even when the underlying <strong>data experiences</strong> a <strong>profound change</strong> (<strong>e.g.</strong>, 99<strong>%</strong> of <strong>values</strong> are suddenly null, or the <strong>type</strong> of a <strong>column</strong> used for <strong>indexing</strong> is unexpectedly inferred as float). The <strong>point</strong> is not that there is no <strong>way</strong> to deal with <strong>issues</strong> (as readers will surely know). The <strong>point</strong> is that there seem to be a <strong>million</strong> of these <strong>ways</strong> to shoot yourself in the <strong>foot</strong> when the <strong>language</strong> does not force you deal with <strong>errors</strong> or <strong>edge</strong> cases. Finally, <strong>engineers</strong> and <strong>devops</strong> already love Go. This is evidenced by the growing <strong>number</strong> of small and even large <strong>companies</strong> developing the <strong>bulk</strong> of their <strong>technology stack</strong> in Go. <strong>Go</strong> allows them to build easily deployable and maintainable <strong>services</strong> <strong>(</strong>see <strong>points</strong> 1 and 2 above) that can also be highly concurrent and scalable <strong>(</strong>important in modern micro<strong>services</strong> environments). By <strong>working</strong> in <strong>Go</strong>, <strong>data scientists</strong> can be unified with their <strong>engineering organization</strong> and produce data-driven <strong>applications</strong> that <strong>fit</strong> right in with the <strong>rest</strong> of their company’s architecture. Note a few things here. The <strong>point</strong> is not that <strong><strong><strong>Go</strong></strong></strong> is perfect for every <strong>scenario</strong> imaginable, so <strong><strong>data scientists</strong></strong> should use <strong><strong><strong>Go</strong></strong></strong>, or that <strong><strong><strong>Go</strong></strong></strong> is fast and scalable <strong>(</strong>which it is), so <strong><strong>data scientists</strong></strong> should use <strong><strong><strong>Go</strong></strong></strong>. The <strong>point</strong> is that <strong>Go</strong> can help <strong>data scientists</strong> produce <strong>deliverables</strong> that are actually useful in an organization and that they will be able to support. Moreover, <strong>data scientists</strong> really should love <strong>Go</strong>, as it alleviates their main <strong>struggles</strong> while still providing them the <strong>tooling</strong> to be productive, as we will see below (with the added <strong>benefits</strong> of <strong>efficiency</strong>, <strong>scalability</strong>, and low memory usage). The <strong><strong>Go</strong></strong> <strong><strong>data</strong></strong> <strong><strong>science</strong> ecosystem</strong> 

 <strong>Ok</strong>, you might buy into the <strong>fact</strong> that <strong><strong>Go</strong></strong> is adored by <strong>engineers</strong> for its <strong>clarity</strong>, <strong>ease</strong> of <strong>deployment</strong>, low <strong>memory use</strong>, and <strong>scalability</strong>, but can <strong>people</strong> actually do <strong><strong>data</strong></strong> <strong>science</strong> with <strong><strong>Go</strong></strong>? <strong>Are</strong> there things like <strong>pandas</strong>, <strong>numpy</strong>, etc., in Go? What if I want to train a model—can I do that with Go? <strong>Yes</strong>, <strong>yes</strong>, and <strong>yes</strong>! In <strong>fact</strong>, there are already a great <strong>number</strong> of open <strong>source</strong> <strong>tools</strong>, <strong>packages</strong>, and re<strong>source</strong>s for doing <strong><strong>data</strong></strong> <strong>science</strong> in <strong><strong>Go</strong></strong>, and <strong>communities</strong> and <strong>organization</strong> such as the high <strong>energy</strong> <strong>physics</strong> <strong>community</strong> and the coral <strong>project</strong> are actively using <strong><strong>Go</strong></strong> for <strong><strong>data</strong></strong> <strong>science</strong>. I will highlight some of this tooling shortly (and a more complete list can be found here ). However, before I do that, <strong>let’s</strong> take a <strong>minute</strong> to think about what <strong>sort</strong> of tooling we actually need to be productive as data scientists. <strong>Contrary</strong> to popular <strong>belief</strong> and as evidenced by <strong>polls</strong> and <strong>experience</strong> (<strong>see</strong> here and here , for <strong>example</strong>), <strong><strong><strong>data</strong></strong> scientists</strong> spend most of their <strong>time</strong> (around 90<strong>%</strong>) gathering <strong><strong>data</strong></strong>, organizing <strong><strong>data</strong></strong>, parsing <strong>values</strong>, and doing a <strong>lot</strong> of basic arithmetic and statistics. Sure, they get to train a <strong>machine learning model</strong> on <strong>occasion</strong>, but there are a huge <strong>number</strong> of <strong>business</strong> <strong>problems</strong> that can be solved via some <strong>data</strong> gathering/organization/cleaning and aggregation/statistics. Thus, in <strong>order</strong> to be productive in <strong>Go</strong>, <strong><strong><strong>data</strong></strong> scientists</strong> must be able to gather <strong><strong>data</strong></strong>, organize <strong><strong>data</strong></strong>, parse <strong>values</strong>, and do arithmetic and statistics. Also, keep in <strong>mind</strong> that, as <strong>gophers</strong>, we want to produce clear <strong>code</strong> over being <strong>clever</strong> (a <strong>feature</strong> which also helps us as <strong>scientists</strong> or data <strong>scientists</strong>/engineers) and introduce a little <strong>copying</strong> rather than a little dependency. In some <strong>cases</strong>, writing a for <strong>loop</strong> may be preferable over importing a <strong>package</strong> just for one function. You might want to write your own <strong><strong>function</strong></strong> for a Chi-squared <strong>measure</strong> of <strong>distance</strong> metric <strong>(</strong>or just copy that <strong><strong>function</strong></strong> into your <strong>code</strong>) rather than pulling in a whole <strong>package</strong> for one of those things. This <strong>philosophy</strong> can greatly improve <strong>readability</strong> and give your <strong>colleagues</strong> a clear picture of what you are doing. Nevertheless, there are <strong>occasions</strong> where importing a well-understood and well-maintained <strong>package</strong> <strong>saves</strong> considerable <strong>effort</strong> without unnecessarily reducing clarity. The following provides something of a “state of the ecosystem” for common data science/analytics activities. <strong>See</strong> here for a more complete <strong>list</strong> of active/maintained <strong>Go</strong> <strong>data</strong> <strong>science</strong> <strong>tools</strong>, <strong>packages</strong>, <strong>libraries</strong>, etc. <strong>Data</strong> <strong>gathering</strong>, <strong><strong>organization</strong></strong>, and parsing 

 Thankfully, <strong><strong>Go</strong></strong> has already proven itself useful at <strong>data</strong> <strong>gathering</strong> and <strong><strong>organization</strong></strong>, as evidenced by the <strong>number</strong> and <strong>variety</strong> of <strong>data</strong>bases and <strong>data</strong>stores written in <strong><strong>Go</strong></strong>, including <strong>InfluxDB</strong> , <strong>Cayley</strong> , <strong>LedisDB</strong> , <strong>Tile38</strong> , <strong>Minio</strong> , <strong>Rend</strong> , and CockroachDB . <strong>Go</strong> also has <strong>libraries</strong> or <strong>APIs</strong> for all of the commonly used <strong>datastores</strong> (<strong>Mongo</strong>, <strong>Postgres</strong>, <strong>etc</strong>.). However, regarding <strong>parsing</strong> and cleaning <strong>data</strong>, you might be surprised to find out that <strong>Go</strong> also has a lot to offer here as well. To highlight just a few: 


 
 
 <strong>G<strong><strong>JSON</strong></strong> —qui<strong>c</strong>k</strong> <strong>parsing</strong> of <strong><strong>JSON</strong></strong> <strong>values</strong> 

 
 <strong>ffjson</strong> —fast <strong><strong>JSON</strong></strong> serialization 

 
 gota —data frames 

 
 <strong>c</strong> svutil —registering a <strong><strong>CSV</strong></strong> <strong>file</strong> as a <strong>table</strong> and running <strong>SQL</strong> <strong>statements</strong> on the <strong><strong>CSV</strong></strong> <strong>file</strong> 

 
 s<strong>c</strong>rape —web s<strong>c</strong>raping 

 
 go-freeling <strong>—NLP</strong> 
 

 Arithmeti<strong>c</strong> and statisti<strong>c</strong>s 

 This is an <strong>area</strong> where <strong>Go</strong> has greatly improved over the last <strong>c</strong>ouple of years. The <strong>gonum organization</strong> provides numerical <strong>functionality</strong> that can power a great <strong>number</strong> of common <strong>data</strong> <strong>science</strong> related computations. There is even a <strong>proposal</strong> to add multidimensional <strong>slices</strong> to the language itself. In general, the <strong>Go</strong> <strong>community</strong> is producing a some great <strong>projects</strong> related to arithmetic, <strong>data</strong> <strong>analysis</strong>, and statistics. Here are just a few: 


 
 
 <strong>math</strong> —stdlib <strong>math</strong> functionality 

 
 gonum/matrix <strong>—matrices</strong> and matrix operations 

 
 gonum/floats —various <strong>helper</strong> <strong>functions</strong> for dealing with <strong>slices</strong> of floats 

 
 gonum/stats —statistics including <strong>covariance</strong>, <strong>PCA</strong>, <strong>ROC</strong>, etc. gonum/graph or <strong>gograph</strong> —graph <strong><strong>data</strong></strong> <strong>structure</strong> and <strong>algorithms</strong> 

 
 gonum/optimize <strong>—function</strong> <strong>optimizations</strong>, <strong>minimization</strong> 
 

 <strong>Exploratory</strong> <strong>analysis</strong> and <strong>visualization</strong> 

 <strong>Go</strong> is a compiled <strong>language</strong>, so you can’t do exploratory <strong><strong>data</strong></strong> <strong>analysis</strong>, right? Wrong. In <strong>fact</strong>, you don’t have to abandon certain <strong>things</strong> you hold dear like <strong>Jupyter</strong> when working with Go. <strong>Check</strong> out these <strong>projects</strong>: 


 
 
 <strong>gophernotes</strong> —<strong>Go</strong> <strong>kernel</strong> for <strong>Jupyter</strong> <strong>notebooks</strong> 

 
 dashing-go —dashboarding 

 
 <strong>gonum/plot</strong> —plotting 
 


 <strong>In</strong> <strong>addition</strong> to this, it is worth <strong>noting</strong> that <strong>Go</strong> fits in so well with <strong>web development</strong> that powering <strong>visualizations</strong> or web <strong>apps</strong> (<strong>e.g.</strong>, utilizing <strong>D3 )</strong> via <strong>custom</strong> <strong>APIs</strong>, etc., can be extremely successful. <strong>Machine learning</strong> 

 Even though the <strong>above</strong> tooling <strong>makes <strong>data scientists</strong></strong> productive about 90<strong>%</strong> of the <strong>time</strong>, <strong>data scientists</strong> still need to be able to do some <strong>machine learning</strong> (and let’s <strong>face</strong> it, <strong>machine learning</strong> is awesome!). So when/if you need to scratch that <strong>itch</strong>, <strong>Go</strong> does not disappoint: 


 
 
 <strong>sajari/regression</strong> —multivariable regression 

 
 goml , <strong>golearn</strong> , and <strong>hector</strong> —general <strong>purpose <strong><strong>machine</strong></strong></strong> learning 

 
 bayesian —bayesian <strong>classification</strong>, TF-IDF 

 
 sajari/word2vec —word2vec 

 
 go-neural , <strong>gonn</strong> , and neurgo —neural <strong>networks</strong> 
 


 And, of <strong>course</strong>, you can integrate with any <strong>number</strong> of <strong><strong>machine</strong></strong> learning <strong>frameworks</strong> and <strong>APIs (</strong>such as <strong>H2O</strong> or <strong>IBM Watson )</strong> to enable a whole <strong>host</strong> of <strong><strong>machine</strong></strong> learning functionality. There is also a <strong>Go API</strong> for <strong>Tensorflow</strong> in the works. <strong>Get</strong> started with <strong><strong><strong><strong>Go</strong></strong></strong></strong> for <strong><strong>data</strong></strong> <strong><strong>science</strong></strong> 

 The <strong><strong><strong><strong>Go</strong></strong></strong></strong> <strong><strong>community</strong></strong> is extremely welcoming and helpful, so if you are curious about developing a <strong><strong>data</strong></strong> <strong><strong>science</strong></strong> application or <strong>service</strong> in <strong><strong><strong><strong>Go</strong></strong></strong></strong> or if you just want to <strong>experiment</strong> with <strong><strong>data</strong></strong> <strong><strong>science</strong></strong> using <strong><strong><strong><strong>Go</strong></strong></strong></strong>, make sure you get plugged into <strong><strong>community</strong></strong> <strong>events</strong> and discussions. The easiest <strong>place</strong> to start is on <strong>gophers</strong> slack , the <strong>golang-nuts</strong> mailing <strong><strong>list</strong></strong> (focused generally on Go), or the <strong>gopherds</strong> mailing <strong><strong>list</strong></strong> (focused more specifically on <strong>data</strong> science). The #data-science channel is extremely active and welcoming, so be sure to introduce yourself, ask questions, and get involved. Many larger <strong>cities</strong> have <strong>Go</strong> meetups as well. <strong>Thanks</strong> to <strong>Sebastien Binet</strong> for providing <strong>feedback</strong> on this post. <strong>Continue</strong> <strong>reading</strong> <strong>Data</strong> <strong>science</strong> gophers.</body>
</html>