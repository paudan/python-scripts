<html>
    <head>
        <title>Renaming isomorphic JavaScript? Interactions</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    </head>
    <body>[caption id="<strong>attachment_80286</strong>" <strong>align=</strong>"<strong>alignright</strong>" <strong>width=</strong>"341"] <strong>Abbott</strong> and <strong>Costello</strong> <strong>performing</strong> "Who's on First?" [/caption] 
 <strong>Abbott</strong> and <strong>Costello</strong>'s <strong>signature wordplay sketch</strong> "Who's on First?" is one of the most renowned comedic routines of all time. Trying to describe the routine here will do it little justice, you'll just have to watch it yourself . As funny as it may be, the <strong>sketch</strong> <strong>reveals</strong> a crucial <strong>fact</strong>: names are important. <strong>Good</strong> names should be self-explanatory, <strong>precise</strong> and reveal intent. Bad <strong>names</strong> leave <strong>people</strong> confused and aggravated and should be avoided at all cost. When we write <strong>code</strong>, we must always think about variable <strong><strong>names</strong></strong>, <strong>function</strong> <strong><strong>names</strong></strong>, file <strong><strong>names</strong></strong>, etc. But naming things is hard. <strong>Phil Karlton</strong> probably said it best: "There are only two hard <strong>things</strong> in <strong>Computer Science</strong>: cache <strong>invalidation</strong> and naming <strong>things</strong>." Since Node.js was first released in 2009, many <strong>developers</strong> have started discussing and implementing <strong>ways</strong> to share <strong>JavaScript</strong> <strong>code</strong> between the <strong>web application server</strong> and the browser. This <strong>sharing</strong> of <strong>JavaScript</strong> <strong>code</strong> allows for assembling <strong>web</strong> <strong>pages</strong> on either the <strong>client</strong> or server, with the <strong>benefits</strong> of faster initial <strong>page load</strong> <strong>times</strong> and improved search engine optimization. The <strong>name</strong> of this <strong>approach</strong> was coined by <strong>Charlie Robbins</strong> and later popularized by <strong>Spike Brehm</strong> as "isomorphic" JavaScript. Such <strong>applications</strong> are isomorphic in the <strong>sense</strong> that they take on equal <strong>(</strong>ἴσος: <strong>isos</strong>) <strong>form</strong> or <strong>shape</strong> <strong>(</strong>μορφή: morphe) regardless of which <strong>environment</strong> they are running on, be it the <strong>browser</strong> or the server. "Isomorphic" <strong>JavaScript</strong> also emphasizes that sharing <strong>code</strong> between the <strong>server</strong> and the <strong>client</strong> requires differentiating environment-specific <strong>code</strong>. "<strong>Isomorphism</strong>" captures the <strong>notion</strong> of two mathematical <strong>objects</strong> that have corresponding or similar <strong>forms</strong> when we simply ignore their individual distinctions. When applying this mathematical concept to graph theory it becomes easy to visualize. <strong>Take</strong> for <strong>example</strong> the two <strong>graphs</strong> in the following figure. [caption id="<strong>attachment_80287</strong>" <strong>align=</strong>"<strong>alignnone</strong>" <strong>width=</strong>"566"] <strong>Example</strong> of isomorphic graphs. [/caption] 
 These graphs are isomorphic, even though they look much different. For <strong>starters</strong>, they both have the same <strong><strong>number</strong></strong> of <strong><strong>node</strong>s</strong> with each <strong>node</strong> containing the same <strong><strong>number</strong></strong> of edges. They are isomorphic because each <strong>node</strong> in the first <strong><strong>graph</strong></strong> maps to a corresponding <strong>node</strong> in the second <strong><strong>graph</strong></strong> while maintaining certain properties. For <strong>example</strong>, the <strong>node</strong> A <strong>can</strong> be mapped to <strong>node</strong> 1 while <strong>maintaining</strong> its <strong>adjacency</strong> in the second graph. In <strong>fact</strong>, all <strong>nodes</strong> in the <strong>graph</strong> have an exact <strong>one-to-one correspondence</strong> while maintaining adjacency. This is what's nice about the "isomorphic" analogy. In <strong>order</strong> for <strong>JavaScript</strong> <strong>code</strong> to run both on the <strong>client</strong> and <strong>server</strong> <strong><strong>environments</strong></strong>, these <strong><strong>environments</strong></strong> have to be isomorphic, that is, there should exist a <strong>mapping</strong> of the <strong>client</strong> environment to the <strong>server</strong> environment functionality, and vice versa. Just as the two isomorphic <strong>graphs</strong> have a mapping, so do isomorphic <strong>JavaScript</strong> environments. For <strong>JavaScript</strong> <strong>code</strong> that does not depend on <strong>environment</strong> specific <strong>features</strong>, for <strong>example</strong>, <strong>avoids</strong> using the "<strong>window</strong>" or "<strong>request</strong>" objects, it can easily run on both <strong>sides</strong> of the wire. But for <strong>JavaScript</strong> <strong>code</strong> that accesses environment-specific <strong>properties</strong>, <strong>e.g.</strong>, "req.path" or "window.location.pathname," a <strong>mapping</strong> needs to be provided to abstract or "<strong>fill</strong> in" (sometimes referred to as a "<strong>shim</strong>") a given environment-specific property. <strong>Iso<strong>morph</strong>ic JavaScript</strong> <strong>applications</strong> may take <strong>advantage</strong> of <strong>build</strong> <strong>scripts</strong> and <strong>tools</strong> like <strong>Browserify</strong> and <strong>Webpack</strong> , which <strong>extract</strong>, <strong>morph</strong>, and <strong>package code</strong> up into a browser-friendly version. "Isomorphic" JavaScript, however, has left some confused and aggravated with its semantic ambiguity. Some have raised <strong>concerns</strong> over the <strong>word</strong>'s <strong>inaccuracy</strong> and the <strong>barrier</strong> it creates for new <strong>developers</strong> to grasp the concept. Many have suggested alternative names. <strong>Michael Jackson</strong>, a React.js <strong>trainer</strong> and <strong>co-author</strong> of the react-router <strong>project</strong> , has suggested the <strong>term</strong> "<strong>universal</strong>" JavaScript . This <strong>term</strong> borrows from <strong>Apple</strong>'s <strong>description</strong> of <strong>app</strong> <strong>bundles</strong> that ran on different <strong>CPU</strong> architectures (i.e. <strong>PowerPC</strong> and Intel) and of <strong>apps</strong> that run on both the <strong>iPad</strong> and the iPhone. Because of <strong>Apple</strong>'s <strong>usage</strong> and the <strong>familiarity</strong> of the <strong>term</strong> in <strong>everyday use</strong>, <strong>Michael</strong> has had better <strong>luck</strong> explaining "<strong>universal</strong>" <strong>JavaScript</strong> to the developers he's trained. The <strong>term</strong> "<strong>universal</strong>" also highlights <strong>JavaScript</strong> <strong>code</strong> that can run "not only on <strong>servers</strong> and <strong>browsers</strong>, but on native <strong>devices</strong> and embedded architectures as well". This gives the <strong>name</strong> a distinct <strong>flavor</strong> and <strong>helps</strong> in expanding the <strong>discussion beyond</strong> the traditional web application client-server model. Yet <strong>others</strong> have suggested <strong>names</strong> like "shared" or "portable" <strong>JavaScript</strong> to <strong>stress</strong> the <strong>commonality</strong> of the <strong>code</strong> running on the <strong>server</strong> and the client. "Cross-environment" and "Full-stack" JavaScript have also come up in this naming discussion. Each of these <strong>names</strong> has its own <strong>merit</strong>, and it's exciting to see the <strong>desire</strong> of the <strong>JavaScript</strong> <strong>community</strong> for <strong>good</strong> <strong>names</strong>. For our <strong>upcoming</strong> O'Reilly <strong>book</strong> we've decided to continue using isomorphic JavaScript. It's a <strong>term</strong> that emphasizes the <strong>right</strong> <strong>things</strong> for us, has become part of the vernacular and is better known than what's been suggested so far. But what do you think? <strong>Please</strong> leave a <strong>comment</strong> below with your <strong>suggestions</strong> and help us name our book. Public domain "Who's on First?" <strong>image</strong> via <strong>Wikimedia</strong> Commons .</body>
</html>